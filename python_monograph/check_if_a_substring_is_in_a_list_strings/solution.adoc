:doctitle: Check if Substring is in a List of Strings Solutions
:author: Jerod Gawne
:email: jerodg@pm.me
:docdate: 04 January 2024
:revdate: {docdatetime}
:doctype: article
:sectanchors:
:sectlinks:
:sectnums:
:toc:
:icons: font
:keywords: solution, python

== Solutions

[.lead]
=== Solution 00

==== Implementation

[source,python,linenums]
----
include::./solution_00.py[]
----

==== Explanation

The provided Python code defines a function named `method_00` that checks if a given substring is present in any of the strings in a list.
The function takes two parameters: `data` and `substr`. `data` is a list of strings where the substring will be searched, and `substr` is the substring to search in the list of strings.

The function signature is as follows:

[source,python]
----
def method_00(data: List[str], substr: str) -> bool:
----

This indicates that the function `method_00` takes in two arguments, `data` which is a list of strings, and `substr` which is a string.
The function returns a boolean value.

The function uses the built-in Python function `any()`.
The `any()` function returns `True` if at least one element of an iterable is true, otherwise it returns `False`.
In this case, the iterable is a generator expression that checks if the substring `substr` is in each string `x` in the list `data`.

The relevant line of code is:

[source,python]
----
return any(substr in x for x in data)
----

This line of code will return `True` if the substring `substr` is found in any string in the list `data`, and `False` otherwise.

NOTE: It's important to note that this function does not provide the location of the substring in the string.
It only checks for the existence of the substring in the list of strings.

==== Advantages
1. **Simplicity**: The method is straightforward and easy to understand.
It uses built-in Python functions and language features, making it accessible to developers familiar with Python.

2. **Efficiency**: The `any()` function stops iterating as soon as it finds an element in the iterable that satisfies the condition.
This means that in the best-case scenario (the substring is found in the first string), the function has a time complexity of O(1).
In the worst-case scenario (the substring is not found or is in the last string), the function has a time complexity of O(n), where n is the total number of characters in all strings in the list.

3. **Versatility**: This method can handle any list of strings and any substring, including empty strings and lists.

==== Disadvantages

1. **Lack of Detailed Information**: The method only checks for the existence of the substring in the list of strings.
It does not provide the location of the substring in the string or in which string(s) the substring was found.

2. **Case Sensitivity**: Python's `in` operator is case-sensitive, which means that the method might not work as expected if the case of the substring and the strings in the list do not match.
If case-insensitive matching is required, additional steps would need to be taken (such as converting all strings to lower or upper case before the check).

3. **No Pattern Matching**: The method checks for exact matches of the substring in the strings in the list.
It does not support pattern matching or regular expressions.
If more complex searches are required, a different method might be more suitable.

==== Complexity Analysis
**Time Complexity**: The time complexity of the function is O(n*m), where n is the number of strings in the list and m is the average length of the strings.
This is because for each string in the list, the function checks if the substring exists within it.
The 'in' operator, used to check if the substring exists in a string, has a time complexity of O(m), where m is the length of the string.
Therefore, if there are n strings in the list, the total time complexity becomes O(n*m).

**Space Complexity**: The space complexity of the function is O(1), which means it uses constant space.
This is because the function only uses a fixed amount of space to store the input and variables, and does not use any additional data structures whose size depends on the input.
The generator expression used in the 'any' function does not generate all its values at once, but one at a time, thus it doesn't use additional space proportional to the size of the input list.

==== Tests

[source,python,linenums]
----
include::./tests/test_solution_00.py[]
----


=== Solution 01

==== Implementation

[source,python,linenums]
----
include::./solution_01.py[]
----

==== Explanation

The provided Python code defines a function named `method_01` that checks if a given substring is present in any of the strings in a list.
The function takes two parameters: `data` and `substr`. `data` is a list of strings where the substring will be searched, and `substr` is the substring to search in the list of strings.

The function signature is as follows:

[source,python]
----
def method_01(data: List[str], substr: str) -> bool:
----

This indicates that the function `method_01` takes in two arguments, `data` which is a list of strings, and `substr` which is a string.
The function returns a boolean value.

The function uses the `find()` method of Python strings.
The `find()` method returns the lowest index in the string where the substring is found.
If the substring is not found, the `find()` method returns -1. In this case, the function iterates over each string `row` in the list `data`, and checks if the substring `substr` is found in `row`.

The relevant lines of code are:

[source,python]
----
for row in data:
    if row.find(substr) != -1:  # Returns -1 if not found
        return True
----

These lines of code will return `True` if the substring `substr` is found in any string in the list `data`, and `False` otherwise.

It's important to note that this function does not provide the location of the substring in the string.
It only checks for the existence of the substring in the list of strings.

==== Advantages
1. **Simplicity**: The method is straightforward and easy to understand.
It uses built-in Python functions and language features, making it accessible to developers familiar with Python.

2. **Efficiency**: The `find()` method stops iterating as soon as it finds an element in the iterable that satisfies the condition.
This means that in the best-case scenario (the substring is found in the first string), the function has a time complexity of O(1).
In the worst-case scenario (the substring is not found or is in the last string), the function has a time complexity of O(n), where n is the total number of characters in all strings in the list.

3. **Versatility**: This method can handle any list of strings and any substring, including empty strings and lists.

==== Disadvantages
1. **Lack of Detailed Information**: The method only checks for the existence of the substring in the list of strings.
It does not provide the location of the substring in the string or in which string(s) the substring was found.

2. **Case Sensitivity**: Python's `find()` method is case-sensitive, which means that the method might not work as expected if the case of the substring and the strings in the list do not match.
If case-insensitive matching is required, additional steps would need to be taken (such as converting all strings to lower or upper case before the check).

3. **No Pattern Matching**: The method checks for exact matches of the substring in the strings in the list.
It does not support pattern matching or regular expressions.
If more complex searches are required, a different method might be more suitable.

==== Complexity Analysis
**Time Complexity**: The time complexity of the function is O(n*m), where n is the number of strings in the list and m is the average length of the strings.
This is because for each string in the list, the function checks if the substring exists within it.
The 'find()' method, used to check if the substring exists in a string, has a time complexity of O(m), where m is the length of the string.
Therefore, if there are n strings in the list, the total time complexity becomes O(n*m).

**Space Complexity**: The space complexity of the function is O(1), which means it uses constant space.
This is because the function only uses a fixed amount of space to store the input and variables, and does not use any additional data structures whose size depends on the input.

==== Tests

[source,python,linenums]
----
include::./tests/test_solution_01.py[]
----
